=========================
=== CPU Specification ===
=========================

=== Overview ===
A custom 8-bit CPU with a 16-bit register architecture, supporting basic arithmetic, logic, memory, and control flow instructions. The ALU uses combinational logic, and the instruction set is designed for compact encoding with variable-length instructions (1-3 bytes).

=== Instructions ===
0x0: ADD^	reg, imm8/reg		-> reg = reg + imm8/reg
0x1: SUB^	reg, imm8/reg		-> reg  = reg - imm8/reg
0x2: NAND	reg, imm8/reg		-> reg = ~(reg & imm8/reg)  
0x3: SBB^	reg, imm8/reg		-> reg = reg - imm8/reg - b    
0x4: XOR	reg, imm8/reg		-> reg = reg ^ imm8/reg  
0x5: NOR	reg, imm8/reg		-> reg = ~(reg | imm8/reg)   
0x6: MOV	reg, imm8/reg		-> reg = imm8/reg 
0x7: LDR	reg, [imm16/reg]	-> reg = [imm16/reg]  
0x8: STR	[imm16/reg], reg	-> [imm16/reg] = reg    
0x9: JNZ	imm16/reg		-> PC = imm16/reg if flag Z == 1 else NOP
0xA: ADC^	reg, imm8/reg		-> reg = reg + imm8/reg + c  
0xB: LDA	reg, [imm16]		-> reg = imm16    
0xC: SHL^	reg 			-> reg = reg << 1  
0xD: SHR^	reg			-> reg  = reg >> 1  
0xE: PUSH	imm8/reg		-> [SP--] = imm8/reg     
0xF: POP	reg			-> reg = [++SP]    


^: The instruction marked with this symbol are affected or affect the carry flag if the instructions
are not marked with this symbol they will not affect in any way this flag.
*Only LDA will affect the 16 bits of the register, all the other operations will affect the LSB.
*Only the AL operations affect the zero flag.

=== Registers ===
8  16 bit registers (in the VHDL code is shown as 16*8b registers, made to make the XST happy, it have two reg arch)
									BYTE_SEL|	REG_SEL	
	R0 		(0x0) : GP register 		(LSB 0 reg) 	0		000
	R1		(0x1) : GP register 		(LSB 1 reg) 	0		001
	R2		(0x2) : GP register 		(LSB 2 reg) 	0		010
	R3		(0x3) : GP register 		(LSB 3 reg) 	0		011
	R4		(0x4) : GP register 		(LSB 4 reg) 	0		100
	R5		(0x5) : GP register 		(LSB 5 reg) 	0		101
	R6		(0x6) : GP register  		(LSB 6 reg)     0		110
	SP		(0x7) : Stack Pointer		(7 reg)	    	X		111

*Separated register for PC, will only be changed with jnz instruction.
*FG register can only be changed by the ALU.
*Calling convention
	*R0-R6, SP, FG for arguments.
	*BYTE_SEL is controlled by the CU.
	
=== Microcode === 
256 x 24b ROM
0x00...0FF

address Layout is XXXYZZZZ where:
X: 3-bit used for encoded opcode, since all ALU op do the same they are encoded as "000";
Y: 0 if argumment is imm, 1 if argument is reg.
Z: 4 bits used for MIC.

Max 16 microinstructions per opcode and imm/reg arg.

=== Instruction layout (Explicitly copied from jdh, see channel in youtube) ===

Instruction layout is XXXXYZZZ where
X: 4-bit instruction identifier (see Instructions section)
Y: 0 if argument is imm(8/16), 1 if argument is reg
Z: 3-bit register identifier of a register (see Registers section)

* instructions with reg: reg arguments have the register, could be SRC or DST, encoded in the
  first three bits of the second instruction byte and the other bits are the same of the first byte.
* For LDA/STR, the Y-bit indicates imm16 (0) and full reg (1). Z-bits are ALWAYS reg.
* Instructions can be 1-3 bytes long
    * PUSH/POP with one register argument are one byte instructions
    * LDR/STR with Y=0 (imm16) are 3 bytes each.
    * LDA is always 3 bytes.
* Operations that uses SRC as first byte:
	* MOV with REG.

=== Flag register layout ===
Flag register layout is ------ZC where
C: set to 1 if an operation produces a carry or borrow or overflow (ADD/ADC/SUBB/SUB/SHR/SHL).
Z: set to 1 if the result of the operation is zero.
-: Not used.
